%% -*- mode: erlang; -*-
[
 { grb, []},
  %% logger config
  {kernel, [

    % main level
    {logger_level, all},

    % logger formatters
    {logger, [
        {handler, default, logger_disk_log_h,
            #{config => #{file => "log/console.log",
                          type => wrap,
                          max_no_files => 10,
                          max_no_bytes => 52428800}, % 10x5mb
              level => info,
              formatter => {logger_formatter, #{single_line => false,
                                                max_size => 2048}}}}
    ]}
  ]},

  {riak_core, [
    %% riak directories
    {ring_state_dir, "data/data_riak_core"},
    {platform_data_dir, "data/data_riak_core"},

    %% determines how many vnodes will be used
    %% also determines the number of files the log is sliced into
    %% has to be an exponent of 2
    %% low number will decrease file accesses (good for testing) and boot time
    %% high number enables scaling and generates smaller log files
    {ring_creation_size, ${RIAK_RING_SIZE}},

    {handoff_port, ${RIAK_HANDOFF_PORT}}
  ]},

  {grb, [
    %% Configuration for GRB coming form the command line
    %% The IP of this node. We can get this using inet:getif,
    %% but we already told the node which IP to use use in vm.args,
    %% so might as well use that one, too.
    {bounded_ip, "${IP}"},

    %% The port to listen for client commands (default is 7878)
    {tcp_port, ${TCP_LIST_PORT}},
    {tcp_id_len_bits, ${TCP_ID_LEN}},

    %% The port to send/recv inter-dc communication (default is 8989)
    {inter_dc_port, ${INTER_DC_PORT}},

    %% Auto-start book-keeping processes in the background
    %% These processes should start after the ring for a cluster
    %% is fully connected. If the node is not going to be joined
    %% with others, it makes sense to start it with these processes
    %% enabled by default.
    {auto_start_background_processes, false},

    %% How many versions to keep per key
    {version_log_size, 50},

    %% todo(borja): Play with these settings. Add them as env vars?
    %% Timer intervals, in ms.
    %%
    %% How often do we increase our own knownVC entry?
    %% Usually, this entry is updated either when a blue transaction
    %% is committed, or when propagating blue transactions in the background.
    %% Given that background propagation is less frequent, and that a
    %% partition might not receive transactions in a while, we need to perform
    %% automatic ticks from time time.
    {self_blue_heartbeat_interval, 5},

    %% How often should we propagate transactions in the background?
    %% The latency between replicas can be large, so it doesn't make
    %% sense to have a small interval here.
    {propagate_interval, 100},

    %% How often should we propagate clocks in the background?
    %% This is used to update globalKnownMatrix, stableVC and
    %% uniformVC, which controls which transactions from remote
    %% replicas are made visible. Having a high interval here
    %% won't harm local visibility for local transactions, since
    %% transactions will propagate changes to stableVC/uniformVC
    %% as they move between partitions, and keep their local
    %% time for the local replica between transactions, which allows
    %% for read-your-writes even if this interval is high.
    %%
    %% It makes sense for this interval to be similar to the propagate
    %% interval, since it controls the visibility of incoming transactions.
    %% However, we should introduce some jitter so the timers don't fire at
    %% the same time. At the same time, computing the clock is expensive, so
    %% we don't want to do it all the time.
    {broadcast_clock_interval, 150}
  ]}
].
